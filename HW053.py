'''
小淞經歷了千辛萬苦，終於來到了第三關。
這個二維整數陣列以1表示牆壁，0表示通道，構成一個巨大的迷宮。
除了入口和出口的部分，其餘邊界皆為牆壁(1)。
迷宮的入口為迷宮第一行中，挑戰者必須想辦法從入口走到出口。
但是因為路線不唯一，也就是有很多種路徑走法，因此請輸出「最短的步數」。
入口座標固定為(0,1)，出口座標為(1~N-2, M-1)任一點，如下所示：

N為10
M為10

1 0 1 1 1 1 1 1 1 1
1 0 0 0 0 0 1 0 0 1
1 1 0 1 1 1 1 1 0 1
1 1 0 0 0 0 0 0 0 1
1 1 1 0 1 0 1 1 1 1
1 1 1 0 1 0 0 0 0 1
1 0 0 0 1 1 1 1 0 1
1 0 1 1 1 0 0 0 0 0
1 0 0 0 0 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1

給一個N×M的迷宮(3 <= N,M <= 11)，
挑戰者必須求出從入口走到出口的最短路徑步數
上例的解答輸出為15

-----------------------------------------------
輸入說明：
輸入的第一行為列數 N，第二行為行數 M，
接下來 N 行每行代表迷宮的一行，含有以空白隔開的迷宮數字。

輸出說明：
對於每個迷宮，請輸出從入口走到出口的「最短路徑步數」。

-----------------------------------------------
範例輸入

10
10
1 0 1 1 1 1 1 1 1 1
1 0 0 0 0 0 1 0 0 1
1 1 0 1 1 1 1 1 0 1
1 1 0 0 0 0 0 0 0 1
1 1 1 0 1 0 1 1 1 1
1 1 1 0 1 0 0 0 0 1
1 0 0 0 1 1 1 1 0 1
1 0 1 1 1 0 0 0 0 0
1 0 0 0 0 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1

範例輸出

15

'''
dicts=[['u',[0,-1]],['d',[0,1]],['l',[-1,0]],['r',[1,0]]]
x = int(input())
y = int(input())
array=[]
f=[]
mov=[]
c=[]
z=[]
for i in range(y):
    array.append([])
    f.append([])
for i in range(x):
    lines=input().split()
    for j in range(len(lines)):
        array[j].append(int(lines[j]))
        f[j].append(True)
def getAns(col,row,a,b,c):
    if a == row-1:
        c.append("".join(mov))
    for i in dicts:
        if col<=b+i[1][1]:
            continue
        if row<=a+i[1][0]:
            continue
        if array[a+i[1][0]][b+i[1][1]] == 0 and f[a+i[1][0]][b+i[1][1]]:
            f[a+i[1][0]][b+i[1][1]]=False
            mov.append(i[0])
            getAns(col,row,a+i[1][0],b+i[1][1],c)
            mov.pop()
            f[a+i[1][0]][b+i[1][1]]=True
getAns(x,y,1,0,c)
for i in c:
    z.append(len(i))
print(min(z))